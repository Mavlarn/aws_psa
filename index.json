[{"uri":"/pinpoint/using-pinpoint-event-analytics-in-plain-js-webapp/","title":"在纯JS应用中使用 Amazon Pinpoint 的 Analytics 用户行为分析","tags":["Amazon Pinpoint","Endpoint","Analytics"],"description":"在纯JS应用中使用 Amazon Pinpoint 的 Analytics 用户行为分析","content":"Amazon Pinpoint 用户行为分析 Amazon Pinpoint 的其中一个功能是收集客户端的用户行为，并发送到 AWS Pinpoint 服务中进行汇总分析，并结合动态 Segment 实现用户圈选，以及触发用户旅程（Journey），从而实现自动化的营销功能。\nPinpoint Analytics 使用 要使用 Pinpoint Analytics 的用户行为分析功能，我们需要在前端页面或者 App 中，使用相应的 JS 库注册当前用户，并对用户的行为埋点，即记录用户事件。我们有两种方式来使用 JS 库实现埋点。\n使用 Pinpoint JS Sdk。这种方式跟大部分 JS 库的使用类似，就是引入该JS库，在 JS 中初始化 Pinpoint Client，初始化时需要传递认证信息。这样就能在页面中通过 JS 库调用 Pinpoint 的 API 实现各种功能，包括记录事件、创建Segment、Campaign等。 使用 Amplify 工具。Amplify 是一系列命令行工具和 JS 库的集合。使用 Amplify，我们可以通过命令行来给我们现有的前端应用添加 AWS 服务，并通过提供的 Amplify 库与后端的 AWS 服务进行交互。例如访问后端的 S3 文件存储服务，DynamoDB 数据库，API Gateway 等等。 在本文中，我们就介绍如何使用 Amplify 来为我们的前端应用添加用户分析的功能，并通过用户属性和 Pinpoint 的 Segment 功能，实现动态圈选用户，为后续的 Campaign 或者 用户 Journey 提供支持。\n实现 场景介绍和前提 本文中，假设我们有一个前端页面是纯 JS 的应用，比如只使用了 JQuery 之类的库实现了前端交互。同时，这样的前端应用往往不会使用 NPM 这样的JS 库依赖管理功能，所以我们希望将 JS 库以及 初始化的方法打包好，在每个页面的 script 标签中引入这个包，然后使用 Pinpoint Analytics 的方法来记录事件。\n如果您的前端应用使用了 Vue、Angular 或 React 等框架，可以参考 Amplify 在线文档 中的说明。\n初始化 Amplify 应用 首先，在现有的前端应用的根目录，运行下面的命令初始化 Amplify。（有关 Amplify 工具的安装和设置，请参考官方文档）\namplify-js-app % amplify init 将看到如下的日志：\nNote: It is recommended to run this command from the root of your app directory ? Enter a name for the project amplifyjsapp The following configuration will be applied: Project information | Name: amplifyjsapp | Environment: dev | Default editor: Visual Studio Code | App type: javascript | Javascript framework: none | Source Directory Path: src | Distribution Directory Path: dist | Build Command: npm run-script build | Start Command: npm run-script start ? Initialize the project with the above configuration? Yes Using default provider awscloudformation ? Select the authentication method you want to use: AWS profile For more information on AWS Profiles, see: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html ? Please choose the profile you want to use MTProj Adding backend environment dev to AWS Amplify app: d39nrrswky58lm ⠴ Initializing project in the cloud... CREATE_IN_PROGRESS amplify-amplifyjsapp-dev-133145 AWS::CloudFormation::Stack Mon Nov 14 2022 13:31:50 GMT+0800 (GMT+08:00) User Initiated CREATE_IN_PROGRESS DeploymentBucket AWS::S3::Bucket Mon Nov 14 2022 13:31:54 GMT+0800 (GMT+08:00) CREATE_IN_PROGRESS AuthRole AWS::IAM::Role Mon Nov 14 2022 13:31:55 GMT+0800 (GMT+08:00) CREATE_IN_PROGRESS UnauthRole AWS::IAM::Role Mon Nov 14 2022 13:31:55 GMT+0800 (GMT+08:00) CREATE_IN_PROGRESS AuthRole AWS::IAM::Role Mon Nov 14 2022 13:31:56 GMT+0800 (GMT+08:00) Resource creation Initiated CREATE_IN_PROGRESS DeploymentBucket AWS::S3::Bucket Mon Nov 14 2022 13:31:56 GMT+0800 (GMT+08:00) Resource creation Initiated CREATE_IN_PROGRESS UnauthRole AWS::IAM::Role Mon Nov 14 2022 13:31:56 GMT+0800 (GMT+08:00) Resource creation Initiated ⠇ Initializing project in the cloud... CREATE_COMPLETE AuthRole AWS::IAM::Role Mon Nov 14 2022 13:32:13 GMT+0800 (GMT+08:00) CREATE_COMPLETE UnauthRole AWS::IAM::Role Mon Nov 14 2022 13:32:14 GMT+0800 (GMT+08:00) ⠧ Initializing project in the cloud... CREATE_COMPLETE DeploymentBucket AWS::S3::Bucket Mon Nov 14 2022 13:32:17 GMT+0800 (GMT+08:00) ⠧ Initializing project in the cloud... CREATE_COMPLETE amplify-amplifyjsapp-dev-133145 AWS::CloudFormation::Stack Mon Nov 14 2022 13:32:19 GMT+0800 (GMT+08:00) ✔ Successfully created initial AWS cloud resources for deployments. ✔ Help improve Amplify CLI by sharing non sensitive configurations on failures (y/N) · no ✔ Initialized provider successfully. ✅ Initialized your environment successfully. Your project has been successfully initialized and connected to the cloud! 成功执行以后，它将在 AWS 创建几个角色，AuthRole 和 UnauthRole，用于已登陆的用户和匿名用户通过 Cognito Identity Pool 来访问 AWS 后端服务。由于我们现在还没有添加任何的其他服务，所以当我们查看这两个角色的 Policy 的时候，不会看到其他权限设置。\n添加 analytics 服务 然后，我们将添加 Pinpoint analytics 服务，这个服务对应 AWS 的 Pinpoint 服务的事件分析功能。在根目录运行下面的命令：\namplify add analytics 它将提示我们创建一个 Pinpoint 的项目，我们需要提供一个项目名称。执行完成后，我们再运行\namplify push 运行 Push 以后，Amplify将会按照之前命令行的配置，为我们生成 CloudFormation 文件，并用该文件创建后台的 Pinpoint 资源。\n如果我们已经创建好了 Pinpoint 的项目，想使用现有的项目的话，可以忽略 add analytics 的步骤，直接 push 即可，之后可以通过修改 json 配置来使用现有的 Pinpoint 项目。\n检查生成的 json 文件 通过 Amplify 工具添加服务之后，它通过 CloudFormation 来为我们创建 AWS 资源，然后将创建的资源的 id 等信息保存在 aws-exports.js 文件中。\n运行上面的 add analytics 和 push 之后，它的内容如下：（在这个文件中，我们需要的主要是三个配置）\nconst awsmobile = { \u0026#34;aws_project_region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;aws_cognito_identity_pool_id\u0026#34;: \u0026#34;us-east-1:c923c1f1-285a-4b1d-acad-c19c61c2287f\u0026#34;, \u0026#34;aws_mobile_analytics_app_id\u0026#34;: \u0026#34;1e4f01b0a02c495d96c9c8410eac246e\u0026#34; }; export default awsmobile; 其中，aws_cognito_identity_pool_id 是 Amplify 为我们创建的 identity pool 的 ID，aws_mobile_analytics_app_id 是 Amplify 为我们创建的项目的 ID。如果要使用现有的 Pinpoint 项目，甚至现有的 Cognito Identity Pool，可以修改这个文件，使用现有资源的 ID 即可。\n初始化 Amplify Analytics 在官方文档中，使用 NPM 引入 aws-amplify 库，并使用 Webpack 进行打包。但是在我们本实例中，假设用户并没有使用 NPM 管理依赖。所以，我们的方法大致如下：\n创建一个临时的js应用，按照官方文档的方式加载 amplify 库 在 app.js 中初始化我们的 Pinpoint Analytics 服务 使用 Webpack 将js文件打包成一个 bundle.js 文件 在真实项目的html页面中，引入该 bundle 文件，并通过 script 脚本在需要在页面或按钮上记录事件。 所以，我们按照上面文档创建一个js应用，并创建一些文件，其中 app.js 文件代码如下：\nimport { Amplify, Analytics, Auth } from \u0026#34;aws-amplify\u0026#34;; import awsExports from \u0026#39;./aws-exports\u0026#39; Amplify.Logger.LOG_LEVEL = \u0026#39;DEBUG\u0026#39; // 开启debug，生产环境建议删掉这一行 const config = { Auth: { region: awsExports.aws_project_region, identityPoolId: awsExports.aws_cognito_identity_pool_id }, Analytics: { // OPTIONAL - disable Analytics if true disabled: false, // OPTIONAL - Allow recording session events. Default is true. autoSessionRecord: true, AWSPinpoint: { appId: awsExports.aws_mobile_analytics_app_id, region: awsExports.aws_project_region, mandatorySignIn: false, // endpointId: \u0026#39;1234\u0026#39;, endpoint: { address: \u0026#39;aws-amplify-jsapp-123\u0026#39;, // 只有 SMS、Email中有意义 attributes: { hobbies: [\u0026#39;piano\u0026#39;, \u0026#39;hiking\u0026#39;] // 用户在该通道的属性 }, channelType: \u0026#39;IN_APP\u0026#39;, // 渠道类型，如果要通知，则需要设置相应类型 metrics: { // Custom metrics that your app reports to Amazon Pinpoint. age: 39 }, optOut: \u0026#39;NONE\u0026#39;, // Customized userId，一个用户可以有多个 endpoint userId: \u0026#39;mav_123\u0026#39;, // User attributes userAttributes: { interests: [\u0026#39;football\u0026#39;, \u0026#39;basketball\u0026#39;, \u0026#39;AWS\u0026#39;], FirstName: [\u0026#39;Mavlarn\u0026#39;] } } } } } Amplify.configure(config); const currentAuthConfig = Auth.configure(); console.log(\u0026#39;amplify auth config:\u0026#39;, JSON.stringify(currentAuthConfig)) // 将这两对象放在window，可以作为全局对象使用，而无需通过 import。 window.Amplify = Amplify window.Analytics = Analytics 代码中的设置以及其作用以及在代码中注释，这里就不再赘述。\n记录事件 项目的其他文件的代码都跟上面的文档中一样，完成后运行 npm dev，就可以编译生成 bundle js文件在 dist 目录中，我们就可以在其他页面引入这个文件，并记录事件：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Amplify Demo\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;app-header\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;recordEvent()\u0026#34;\u0026gt;Record Event\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;main.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function recordEvent() { // 由于我们已经通过 window.Analytics = Analytics 将它作为全局对象，所以可以直接调用它的方法。 Analytics.record({ name: \u0026#39;Custom_event\u0026#39; }); // 记录自定义事件 Custom_event } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这个 js 应用实例的完整代码，可以参考 Github 上的实例项目。读者可以直接从这个实例项目中的 dist 文件中找到已经打包好的 hundle.js 文件，然后修改其中的 aws_mobile_analytics_app_id 等配置来直接使用。\n更新 Endpoint 属性 我们提到我们使用 Pinpoint Analytics 的事件分析功能，一个主要目的就是结合 Campaign 和 Journey 功能，实现动态的选择所需的用户。例如在一个 Campaign 活动中，我们想要选择一天之内注册的用户，那我们就可以给用户的 Endpoint 设置一个 registeredDate，值就是注册时间，然后在 Campaign 的 Segment 里，创建一个动态 Segment，其条件就是注册时间晚于一天前。\n所以，我们可以在应用中适当的地方更新用户的 Endpoint：\n\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;app-body\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Update Endpoint\u0026lt;/h1\u0026gt; \u0026lt;button onclick=\u0026#34;updateEndpoint()\u0026#34;\u0026gt;Update Endpoint\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;main.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function updateEndpoint() { Analytics.updateEndpoint({ attributes: { registeredDate: [new Date()] } }) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在该实例的 html 中，我们引入了之前打包的 hundle.js 文件，当用户注册成功后，就可以调用 Analytics.updateEndpoint(...) 方法，并设置 attributes 属性，它是一个对象，它的值会被添加到当前的 Endpoint 的属性当中。我们可以使用这样的方式来给当前用户设置各种业务标签，然后用这些标签来过滤用户。\n检查 Pinpoint 检查 Pinpoint 事件 在页面点击按钮记录事件，或者更新 Endpoint 属性之后，我们就可以在 AWS Pinpoint 的 Console 中查看记录的事件。打开 Console，进入 Pinpoint 服务，在项目列表中找到并点击创建的项目，这里是 amplifyjsapp-dev。在左侧菜单中找到 Analytics - Events，就可以看到统计的 Event 信息。\n如果想要得到所有事件的明细，可以通过设置 Kinesis Stream 将事件流写到 Kinesis 中然后自行处理， 或者 使用 Kinesis Firehose 将事件写到 S3 或其他位置。\n打开 Event 试图，就能够看到事件统计。 默认我们只能按天查看事件的汇总图标，我们可以启用 Filters 功能，来按照事件类型、属性来进行搜索和过滤。例如这里，我们在页面中记录了自定义事件 Custm_event1，我们就可以按这个事件来查看每天的事件数量。也可以按照该事件的属性（如果有的话），或者按照 Endpoint 的属性来进行过滤。\n创建动态 Segment 我们在实例中，通过 updateEndpoint 更新了Endpoint 的属性值，也可以更新用户属性（userAttributes），或者 Metrics，这些都能用来作为创建动态 Segment 的条件。\nAnalytics.updateEndpoint({ attributes: { registeredDate: [new Date()] }, userAttributes: { lastOrderProducts: [\u0026#39;football\u0026#39;, \u0026#39;iphone\u0026#39;, \u0026#39;TV\u0026#39;], userType: [\u0026#39;vip\u0026#39;] }, metrics: { age: 35 } }) 其中 attributes、userAttributes 属性都是 key-value 的对象，它们的值都必须是一个列表。而 metrics 顾名思义，就是一个指标，值应该都是数值类型。\n然后就可以在创建 Segment 的时候，使用这些属性来动态创建 Segment，按需选出想要的用户： 这里，我们使用用户的注册时间晚于11月11号这天作为条件，选出了刚才的实例中测试的那个用户的 Endpoint，这样就可以结合 Campaign 或 Journey 进行其他的自定义的触达活动。创建 Campaign 或 Journey 的其他步骤不是本文的内容，就不做介绍，需要的可以参考相关文档。\n"},{"uri":"/pinpoint/customer-engagement-using-amazon-pinpoint-custom-channel/","title":"使用 Amazon Pinpoint 的Custom Channel给用户发送 Whatsapp 消息","tags":["Amazon Pinpoint","Endpoint","Channel"],"description":"使用 Amazon Pinpoint 的Custom Channel给用户发送 Whatsapp 消息","content":"Amazon Pinpoint 用户触达 Amazon Pinpoint 通常用来通过 SMS 以及邮件的方式来给用户发通知，我们可以创建 Campaign，来动态的给圈选的用户在指定的时间、或某个事件发生的情况下，给用户发送指定模板的消息。更复杂的，我们还可以创建用户旅程的流程，来给用户发消息。\n除了 SMS 和邮件，Pinpoint 还提供了 Push-notification，in-app messaging 的消息，我们甚至还可以通过 Lambda 还创建自定义的消息渠道。本文我们就来看一下如何使用 Lambda 创建自定义的渠道（custom channel）并使用它来发送消息给用户。\n场景描述和前提 本文中，我们希望给用户的 Whatsapp 账号发送消息，实现原理实际上就是在 Lambda 函数内通过调用 Whatsapp 的 API 来发消息。这就需要几个前提：\n创建并配置 Whatsapp Whatsapp 是 Facebook 旗下的产品，它提供 Business Platform API，可以用来直接发送 WhatsApp 消息，而无需通过类似 Twilio 这样的服务。开通和配置的过程不是本文的内容，这里就不做说明。我们需要能够通过 API 调用来发消息。配置完成后，可以同下面的页面来测试：\n它通过临时的 Token 使用 API 发消息；这里的 Phone number ID 是我们的注册的 Business 账号下使用的电话的 Id；To 就是我们要发送消息的对象。\n发送消息后，我们就可以在网页版的 WhatsApp 应用，或手机应用上看到收到的测试消息。\n验证消息接收无误以后，就可以使用 API 调用发送消息了。\n获取 app token 从上面的测试接口页面，我们可以知道测试接口需要几个参数：\ntoken： 即 Facebook app token，在 Facebook business platform 创建，需要保证这个token具有 WhatsApp api的权限。 Phone number ID：即发消息的账号的Id。 创建 template 根据 WhatsApp 的机制，我们需要先创建一个消息模板，然后使用该模板发送消息。所以我们需要创建一个 template：\n该消息的内容为： Hi {{1}}, the {{2}} in your order is not paid yet. Go to pay the order and get extra points!。使用两个变量用来替换消息的内容，实现定制。右侧是消息的展示效果。\n实现 Lambda Pinpoint 消息格式 接下来，我们创建一个 lambda 函数，可以使用 AWS 控制台创建一个空的、NodeJs16 版本 Lambda，index.js 的内容如下：\nexports.handler = async (event) =\u0026gt; { console.log(\u0026#39;Event\u0026#39;, event) if (event.Endpoints === undefined) { const errorText = \u0026#39;Unsupported event type. event. Endpoints not defined.\u0026#39; console.error(errorText) throw new Error(errorText) } const endpoints = event.Endpoints for (var endpointId in endpoints) { const endpoint = endpoints[endpointId] const phoneId = endpoint.Address const customMessage = JSON.parse(event.Data) const templateName = customMessage.templateName const templateParams = customMessage.params await sendWhatsAppTemplateMessage(phoneId, templateName, templateParams) } } 这只是一个处理函数，具体发消息的方法下面再说。Pinpoint 使用定制渠道发送消息的时候，消息的格式如下：\n{ \u0026#34;Message\u0026#34;:{}, \u0026#34;Data\u0026#34;:\u0026#34;The payload that\u0026#39;s provided in the CustomMessage object in MessageConfiguration\u0026#34;, \u0026#34;ApplicationId\u0026#34;:\u0026#34;3a9b1f4e6c764ba7b031e7183example\u0026#34;, \u0026#34;CampaignId\u0026#34;:\u0026#34;13978104ce5d6017c72552257example\u0026#34;, \u0026#34;TreatmentId\u0026#34;:\u0026#34;0\u0026#34;, \u0026#34;ActivityId\u0026#34;:\u0026#34;575cb1929d5ba43e87e2478eeexample\u0026#34;, \u0026#34;ScheduledTime\u0026#34;:\u0026#34;2022-10-08T19:00:16.843Z\u0026#34;, \u0026#34;Endpoints\u0026#34;:{ \u0026#34;1dbcd396df28ac6cf8c1c2b7fexample\u0026#34;:{ \u0026#34;ChannelType\u0026#34;:\u0026#34;EMAIL\u0026#34;, \u0026#34;Address\u0026#34;:\u0026#34;mary.major@example.com\u0026#34;, \u0026#34;EndpointStatus\u0026#34;:\u0026#34;ACTIVE\u0026#34;, \u0026#34;OptOut\u0026#34;:\u0026#34;NONE\u0026#34;, \u0026#34;Location\u0026#34;:{ \u0026#34;City\u0026#34;:\u0026#34;Seattle\u0026#34;, \u0026#34;Country\u0026#34;:\u0026#34;USA\u0026#34; }, \u0026#34;Demographic\u0026#34;:{ \u0026#34;Make\u0026#34;:\u0026#34;OnePlus\u0026#34;, \u0026#34;Platform\u0026#34;:\u0026#34;android\u0026#34; }, \u0026#34;EffectiveDate\u0026#34;:\u0026#34;2022-10-01T01:05:17.267Z\u0026#34;, \u0026#34;Attributes\u0026#34;:{ \u0026#34;CohortId\u0026#34;:[ \u0026#34;42\u0026#34; ] }, \u0026#34;CreationDate\u0026#34;:\u0026#34;2022-10-01T01:05:17.267Z\u0026#34; } } } 每个事件参数中会有一个 Endpoints 的对象，它保存要发送消息的目标端点，其中 key 就是 EndpointId，值就是这个端点的详情，在这个消息内容中，它使用 Email 发消息，目标地址是 mary.major@example.com。在本实例中，我们要发送 WhatsApp 消息，所以我们会给用户创建一个 WhatsApp 类型的 Endpoint，而它的 address 就是 WhatsApp 的手机号。\n传递消息参数 在使用 Pinpoint 发消息时，定制消息的内容放在 event.Data 中，而在这个数据中，我们将模板名和数据都放在这里，这样我们就可以使用同一个 Lambda 的函数，发送多种模板类型的消息。\nconst customMessage = JSON.parse(event.Data) const templateName = customMessage.templateName const templateParams = customMessage.params 保存 Facebook token 和 Phone number ID 还有，我们要掉用 Facebook 的 API，还需要使用 token，而这个 token 一般都需要加密保存，所以我们使用 AWS 的 Secret Manager 服务，创建一个加密的对象来存储，然后在 Lambda 函数中获取这个值，这样就能安全的使用这个token。\n所以，我们打开 Secret Manager Console 界面，Store a new secret，选择 Other type of secret，以 FB_APP_TOKEN 为 key（在代码中要使用这个key来获取token），值就是 Facebook 里面的 token。\n保存之后，我们需要在 Lambda 中得到这个 token 的值，通常的做法是在 Lambda 中创建一个环境变量，将刚才在 Secret Manager 里创建的安全对象的 ARN 值设置到这个环境变量的值。\n所以我们打开 Lambda 的配置界面，按如下方式配置环境变量。\n由于我们在 lambda 中使用这个环境变量的 key 来获取他的值，所以需要使用 FB_BUSINESS_PHONE_ID 和 FB_SECRET_ARN 作为key。\nindex.js 完整代码 下面，就是js中所有的代码，包括处理人口以及发送 WhatsApp 消息的代码：\nonst https = require(\u0026#39;https\u0026#39;) const AWS = require(\u0026#39;aws-sdk\u0026#39;) const BUSINESS_PHONE_ID = process.env.FB_BUSINESS_PHONE_ID const PATH_WHATSAPP = \u0026#39;/v14.0/\u0026#39; + BUSINESS_PHONE_ID + \u0026#39;/messages\u0026#39; let appToken const secretManager = new AWS.SecretsManager() const sendWhatsAppTemplateMessage = async (phoneId, templateName, templateParams) =\u0026gt; { if (appToken === undefined) { await getFacebookSecrets() } const body = { messaging_product: \u0026#39;whatsapp\u0026#39;, recipient_type: \u0026#39;individual\u0026#39;, to: phoneId, type: \u0026#39;template\u0026#39;, template: { name: templateName, language: { code: \u0026#34;en_US\u0026#34; }, components: templateParams } } console.log(\u0026#39;Send FB WhatsApp body\u0026#39;, body) const headers = { Authorization: \u0026#39;Bearer \u0026#39; + appToken, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } const options = { host: \u0026#39;graph.facebook.com\u0026#39;, path: PATH_WHATSAPP, method: \u0026#39;POST\u0026#39;, headers } const result = await new Promise((resolve, reject) =\u0026gt; { const req = https.request(options, (res) =\u0026gt; { let responseBody = \u0026#39;\u0026#39; res.on(\u0026#39;data\u0026#39;, (chunk) =\u0026gt; { responseBody += chunk }) res.on(\u0026#39;end\u0026#39;, () =\u0026gt; { resolve(responseBody) }) }) req.on(\u0026#39;error\u0026#39;, (err) =\u0026gt; { console.error(\u0026#39;Error sending FB WhatsApp message\u0026#39;, err) reject(err) }) req.write(JSON.stringify(body)) req.end() }) const resultObj = JSON.parse(result) console.log(\u0026#39;Send FB WhatsApp Message result\u0026#39;, result) if (resultObj.error !== undefined) { console.error(\u0026#39;Error sending FB WhatsApp message\u0026#39;, resultObj) return false } return true } const getFacebookSecrets = async () =\u0026gt; { if (process.env.FB_SECRET_ARN) { const params = { SecretId: process.env.FB_SECRET_ARN } const response = await secretManager.getSecretValue(params).promise() const sec = JSON.parse(response.SecretString) appToken = sec.FB_APP_TOKEN } else { appToken = null } } exports.handler = async (event) =\u0026gt; { console.log(\u0026#39;Event\u0026#39;, event) if (event.Endpoints === undefined) { const errorText = \u0026#39;Unsupported event type. event. Endpoints not defined.\u0026#39; console.error(errorText) throw new Error(errorText) } const endpoints = event.Endpoints for (var endpointId in endpoints) { const endpoint = endpoints[endpointId] const phoneId = endpoint.Address const customMessage = JSON.parse(event.Data) const templateName = customMessage.templateName const templateParams = customMessage.params await sendWhatsAppTemplateMessage(phoneId, templateName, templateParams) } } 创建 pinpoint app 和 Endpoint 为了测试，我们还需要在 Pinpoint 中创建一个项目，并记录下项目的 Id 备用。然后还需要一个Endpoint，由于我们需要一个 WhatsApp 类型的，这是一个自定义的 Channel 类型，系统中肯定不会有现成的 Endpoint，所以我们使用 aws cli 工具创建一个。\n首先创建一个 test-endpoint.json 文件，内容如下：\n{ \u0026#34;ChannelType\u0026#34;: \u0026#34;CUSTOM\u0026#34;, \u0026#34;Address\u0026#34;: \u0026#34;8613800138000\u0026#34;, \u0026#34;Attributes\u0026#34;: { \u0026#34;Interests\u0026#34;: [ \u0026#34;Technology\u0026#34;, \u0026#34;Music\u0026#34;, \u0026#34;Travel\u0026#34; ] }, \u0026#34;Metrics\u0026#34;: { \u0026#34;technology_interest_level\u0026#34;: 9.0, \u0026#34;music_interest_level\u0026#34;: 6.0, \u0026#34;travel_interest_level\u0026#34;: 4.0 } } 其中，Address 就是你要测试使用的手机号，需要在前面加上国家码（即86）。\n然后使用 AWS Cli 工具运行：\naws pinpoint update-endpoint --application-id f190affea10b4ce2b4a2cbbd85976c96 --profile MTProj --endpoint- id test123 --endpoint-request file://test-endpoint.json 其中，\u0026ndash;application-id 后面是之前创建的pinpoint项目的id，\u0026ndash;profile 是我自己使用的认证方式。执行后，成功的话，就会返回新建的 Endpoint id：\n{ \u0026#34;MessageBody\u0026#34;: { \u0026#34;Message\u0026#34;: \u0026#34;Accepted\u0026#34;, \u0026#34;RequestID\u0026#34;: \u0026#34;b6e9a334-0d51-4b5e-9b87-4aecaad7c966\u0026#34; } } 也可以通过命令获得endpoint信息：\naws pinpoint get-endpoint --application-id f190affea10b4ce2b4a2cbbd85976c96 --endpoint-id test123 --profile MTProj 设置权限 最后，我们还需要合适的权限才能使用这个定制的渠道。\n首先，我们需要知道它的调用逻辑，才能知道谁需要什么权限，来访问谁。在发送定制渠道的消息时，我们通过 API 创建一个 campaign 活动，在 campaign 里面创建一个动态的 Segment；它在执行的时候，会掉用 lambda 函数，而这个 Lambda 函数在执行的时候，又需要从 Secret Manager 读取 Token，所以它的调用关系如下：\npinpoint应用 -\u0026gt; lambda 函数 -\u0026gt; Secret Manager 对象。我们通过给这个 Lambda 函数设置一个 Resource Policy，来允许 Pinpoint 应用可以调用它，然后再给这个 Lambda 的role设置权限，让它能够访问 Secret Manager。\n所以，先打开刚才创建的 Lambda 函数配置页面的 Permission 页：\n在 Resource based policy的部分，添加一条permission：\n选择 AWS service，选择 Other，然后手动输入，其中 Principal 输入 pinpoint.amazonaws.com，Source ARN 填你创建的 Pinpoint 项目的 ARN，我这里最后用星号（*），表示我所有的Pinpoint项目都能调用这个 Lambda 。然后选择Action 为 lambda:InvokeFunction。\n然后，找到这个 Lambda 函数使用的角色，为这个角色添加Policy，来让它能够访问 Secret Manager。在角色的Permission页面，添加一个 Inline Policy，策略内容如下：\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Action\u0026#34;: \u0026#34;secretsmanager:GetSecretValue\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:secretsmanager:us-east-1:56xxxxxx027:secret:connect/facebook-S5G08O\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34; } ] } Resource 的值就是我们之前在 Secret Manager 里创建的对象的 arn。\n通过 Console 创建 Campaign 测试 最后，我们在 Pinpoint 的console 页面，进入之前的项目，创建一个 Campaign 来测试这个新渠道消息。创建的时候，创建 Segment 的时候，我们需要创建一个 Segment，条件设置 Channel Type 为 custom，下面会出来预估的当前这个 Segment 条件下大概会有多少个Endpoint 会被触达。我们这里的测试环境只有一个 CUSTOM 类型的 Endpoint，所以只有1.\n下一步，我们需要选择之前创建的 Lambda 函数，以及使用过 custom 类型的Endpoints。\n然后下一步，选择立即开始，并最后保存这个 Campaign。\n创建完成后，就会跳转到详情页，这个页面中，会展示这个活动圈选了几个 Endpoint，并触达了几个 Endpoint（这里的触达只是表示掉用了 Lambda 函数，至于 Lambda 函数是否成功执行，这里无法体现）。\n注意：我们发送 Whatsapp 消息，使用定制的消息模板，并且模板中还使用变量，而这些变量，也需要通过 Campaign 传递到 Lambda 函数，然后在 API 中使用。 但是，我们使用 Console 进行测试的时候，并没有传递任何参数，所以，实际上，我们通过 Console 测试的时候，Lambda 函数会执行失败，因为没有 event.Data 数据。所以，我们需要通过 API 调用的方式，才能测试带自定义内容的消息。\n通过 API 测试 最后，我们来看一下使用过 JS sdk进行API调用的实例：\nconst ppClient = new PinpointClient({ region: \u0026#34;us-east-1\u0026#34;, credentials: fromCognitoIdentityPool({ identityPoolId: \u0026lt;the_identityPoolId\u0026gt;, client: new CognitoIdentityClient({ region: \u0026#39;us-east-1\u0026#39; }) }) }); const dataObj = [ { \u0026#34;type\u0026#34;: \u0026#34;body\u0026#34;, \u0026#34;parameters\u0026#34;: [ {\u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Tuohumai\u0026#34;}, {\u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34; Champion T Shirt\u0026#34;} ] }, { \u0026#34;type\u0026#34;: \u0026#34;button\u0026#34;, \u0026#34;sub_type\u0026#34;: \u0026#34;quick_reply\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;parameters\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;payload\u0026#34;: \u0026#34;button 0 clicked\u0026#34; } ] } ] const customMessage = { templateName: \u0026#39;ordertimeoutnotification\u0026#39;, params: dataObj } const command = new CreateCampaignCommand({ ApplicationId: \u0026#39;f190affea10b4ce2b4a2cbbd85976c96\u0026#39;, WriteCampaignRequest: { Name: \u0026#39;test-campaign-wa-message-with-api\u0026#39;, Description: \u0026#39;campaign Desc\u0026#39;, SegmentId: \u0026#39;b5b50ccb81644a3390751ee1e4fe27ac\u0026#39;, Schedule: { StartTime: \u0026#34;IMMEDIATE\u0026#34; }, MessageConfiguration: { CustomMessage: { Data: JSON.stringify(customMessage), } }, CustomDeliveryConfiguration: { DeliveryUri: \u0026#39;arn:aws:lambda:us-east-1:568xxxxxx9027:function:mt_pinpoint_whatsapp_custom_channel\u0026#39;, EndpointTypes: [\u0026#34;CUSTOM\u0026#34;] } } }); const response = await ppClient.send(command); console.log(\u0026#34;Success\u0026#34;, response); 在这个代码中，我们先创建了自定义消息所需的参数 dataObj，它跟我们在 WhatsApp 中创建的消息有关，它包括消息内容中要替换的变量 parameters，也有 Whatsapp 里面展示时添加的按钮，以及这个按钮的动作，这都是 WhatsApp 消息所需的内容，跟接口无关。然后我们将这个对象转成 String 以后，放到 MessageConfiguration.CustomMessage.Data 中。\nWriteCampaignRequest 是使用接口创建 Campaign 的对象。通过这个接口，就可以创建一个立即运行的 Campaign，这样就能在 WhatsApp 应用中看到通知的消息了。\n"},{"uri":"/connect/configure-amazon-connect-keycloak-with-saml-sso/","title":"配置Amazon Connect使用Keycloak SAML进行单点登录","tags":["Amazon Connect","Keycloak"],"description":"配置 Amazon Connect 使用 Keycloak SAML 进行单点登录","content":"Amazon Connect Amazon Connect 是云原生的智能呼叫中心服务，它按用户的使用量（电话呼入的时间、以及处理的消息数）进行付费，能够在一天之内搭建客户服务中心，并实现智能流程，所以是企业接入用户的一个非常好的选择。\nAmazon Connect 支持集中用户认证，1) 内置的用户系统 2) Active Directory 3) 基于SAML2.0 的认证服务器。\n如果客户想要在自己的CRM系统，或者客服工作台使用 Amazon Connect，就需要使用 AD 或，基于SAML2.0 的认证服务器，来实现与现有系统的单点登录（SSO）。\n在本文中，我们将介绍如何使用 Keycloak 作为认证服务，通过 SAML 协议为 Amazon Connect 提供单点登录功能。\n如果想要使用 Okta、Azure AD 等认证服务器，请参考 Amazon Connect SSO Setup Workshop。\nKeycloak 与 SAML Keycloak Keycloak 是一款开源的身份与访问控制软件，提供单点登录 (SSO) 功能，支持 OpenID、 OAuth 2.0、SAML 2.0 等标准协议。Keycloak 提供可自定义的用户界面，用于登录、注册和账户管理等。而且，客户可以使用 Keycloak 并将身份验证委派给现有的 LDAP 和 Azure Active Directory，或第三方身份提供商，实现灵活的认证服务。\nSAML 2.0 协议 SAML，即安全断言标记语言（Security Assertion Markup Language）是一个基于 XML 的开源标准数据格式，通过在各方之间交换身份验证和授权数据，实现跨域的单点登录。\nSAML协议中，包含两个主体：\nIdentity Provider 身份提供方，简称 IdP。即通常说的认证服务器，它保存用户及密码等信息，为用户提供登录服务，并在登录成功后为服务提供方提供身份断言（ID Assertion），即标识某个人身份的Token。 Service Provider 服务提供方，简称 SP。即通常所说的应用，如 CRM 系统等，用户在身份提供方登录成功后，会跳转到应用界面进行操作。 两个主体通过浏览器进行信息交换，例如使用带有参数的重定向请求，下图就是 SAML 2.0 协议中，身份提供方、服务提供方、和浏览器进行身份验证的流程：\nsequenceDiagram participant SP participant Browser participant IdP Browser-\u003e\u003eSP: 访问服务 SP-\u003e\u003eSP: 生成 SAML Request SP-\u003e\u003eBrowser: 携带 SAML Request, 重定向到IdP的登录地址 Browser-\u003e\u003eIdP: 携带 SAML Request, 访问IdP的登录地址 IdP-\u003e\u003eIdP: 解析 SAML Request IdP-\u003e\u003eBrowser: 返回登录页面 Browser-\u003e\u003eIdP: 用户登录 IdP-\u003e\u003eIdP: 登录成功，生成SAML Response IdP-\u003e\u003eBrowser: 携带SAML Response，重定向到SP的ACS地址 Browser-\u003e\u003eSP: 携带SAML Response，访问SP的ACS地址 SP-\u003e\u003eSP: 检验SAML Response SP-\u003e\u003eBrowser: 检验成功 Browser-\u003e\u003eSP: 重定向到RelayState页面 在本文中，Keycloak就是IdP，而 Amazon Connect 就是其中一个SP。\nSP 与 IdP 之间通信方式 SP 与 IdP 之间有几种通信方式，\u0026ldquo;HTTP Redirect Binding\u0026rdquo;，\u0026ldquo;HTTP Post Binding\u0026rdquo; 和 \u0026ldquo;HTTP Artifact Binding \u0026ldquo;。\nHTTP Redirect Binding 其中，HTTP Redirect Binding 很好理解，就是说浏览器在SP 和 IdP直接跳转的时候，是通过 HTTP 的重定向请求进行的。例如在访问 SP 时，重定向到 IdP 进行登录：\nsequenceDiagram participant SP participant Browser participant IdP Browser-\u003e\u003eSP: 访问服务 SP-\u003e\u003eSP: 生成 SAML Request SP-\u003e\u003eBrowser: 将 SAML Request 放在URL中, 重定向到IdP的登录URL Browser-\u003e\u003eIdP: 访问IdP的登录地址 由于 SAML Request 要放在 URL 地址中进行重定向，所以会收到长度的限制，也存在一些泄漏风险。\nHTTP Post Binding 而 Post Binding 就是通过一个 POST 请求来实现，其流程如下：\nsequenceDiagram participant SP participant Browser participant IdP Browser-\u003e\u003eSP: 访问服务 SP-\u003e\u003eSP: 生成 SAML Request SP-\u003e\u003eBrowser: 返回一个由JS控制的Form表单 Browser-\u003e\u003eIdP: 浏览器往 IdP 提交该表单（POST请求） 在之后登录成功后，IdP 也是返回一个由JS控制的Form表单，而这个请求则发到 SP 的ACS 地址上。\n由于使用 POST 请求，所以其大小相对于 URL 来说不受限制，而且也比较安全。Keycloak中使用的也是这种绑定方式。\nHTTP Artifact Binding 在这种方式下，SP 和 IdP 双方只通过浏览器交换 SAML Request 和 Response 的编号，收到编号后，都需要再请求对方的相应接口，来获得其真正内容，从而完全避免这些数据暴露在浏览器端。\n配置 Amazon Connect 理解了 SAML 的原理，我们再来看如何为 Amazon Connect 配置 SAML 以及 Keycloak 来实现单点登录。\n通常情况下，我们通过 SAML 访问服务，有以下两种方式：\n直接访问 SP 的应用地址，应用检测到没有登录，就跳转到 IdP 的登录页面，登录成功后跳转回来。但是在 Amazon Connect 中，我们无法设置 Idp 地址，如果我们直接打开 Amazon Connect 的地址，将会显示如下的错误页面。 通过 IdP 的 \u0026ldquo;IDP initiated SSO URL\u0026rdquo; 访问应用，它会检查是否登录，然后在登录成功后，跳转到设置的 \u0026ldquo;IDP Initiated SSO Relay State \u0026quot; 地址。所以，在配置成功 SAML 以后，我们将使用这种方式访问。 结合上面的 SAML 的流程，在 Amazon Connect 和 Keycloak 使用 SAML 进行登录的过程如下：\nsequenceDiagram participant Browser participant IdP SSO URL participant IdP SSO Login URL participant IdP SSO Relay State participant SP (ACS URL) participant SP (Amazon Connect) Browser-\u003e\u003eIdP SSO URL: 访问IdP SSO URL IdP SSO URL-\u003e\u003eBrowser: 重定向到登录页 Browser-\u003e\u003eIdP SSO Login URL: 访问登录页 IdP SSO Login URL-\u003e\u003eIdP SSO Login URL: 登录成功，生成SAML Response IdP SSO Login URL-\u003e\u003eBrowser: 携带SAML Response，重定向到SP的ACS地址 Browser-\u003e\u003eSP (ACS URL): 携带SAML Response，访问SP的ACS地址 SP (ACS URL)-\u003e\u003eSP (ACS URL): 检验SAML Response SP (ACS URL)-\u003e\u003eBrowser: 检验成功, 重定向到 IdP SSO Relay State 地址 Browser-\u003e\u003eIdP SSO Relay State: 访问IdP的 Relay State 地址 IdP SSO Relay State-\u003e\u003eBrowser: 重定向到 Connect 页面 Browser-\u003e\u003eSP (Amazon Connect): 访问 Connect 页面 上图中：\nIdP SSO URL: 即 IDP-Initiated SSO URL，是通过 IdP 发起的，用于访问服务地址。它是在 Keycloak 中创建Client时设置。 IdP SSO Login URL: 即 IdP 的单点登录地址。一般无需设置。 SP (ACS URL): 由 SP 提供的用于检验 SAML Response 的接口，在 AWS 中，该地址是固定的，需要在 Keycloak 设置。 IdP SSO Relay State: 是登录成功后，需要跳转到应用时的 URL。在 AP ACS 检验 SAML Response 成功后，携带身份信息跳转到该 URL，相对于应用的 SAML SSO 入口。在我们这里，如果不设置该 URL，就会跳转到 AWS Console页面。 所以，大致步骤如下：\n创建使用 SAML 的 Amazon Connect 实例。 在 Keycloak 上配置 Amazon Connect 的Client，并进行 SAML 相关配置。 在 Amazon IAM 中创建该 Keycloak 为身份提供商，并创建角色，所有通过 Keycloak 认证的用户都通过该角色来访问 Connect 服务。 安装 Keycloak 安装 Keycloak 不在本文的范围内，如果去 Keycloak 官网进行下载安装。\n在本文中，我下载 ZIP 包在本地运行 Keycloak。本地访问地址是：http://localhost:8080/。本文所使用的 Keycloak 版本是 19.0.3，如果您所使用的版本与这个不一样，可能有部分配置不一样。\n您需要创建 admin 账户，如果需要，创建新的 realm，名称为 AWSDemo： 创建 Amazon Connect 首先，我们需要创建 Amazon Connect 实例，并且选择 \u0026ldquo;SAML 2.0-based authentication\u0026rdquo;。\n第二步需要创建Admin，这里的 Username 就是以Admin来登录 Amazon Connect 的用户名，这里是 \u0026ldquo;mavlarn\u0026rdquo;，而这个用户名必须要跟之后要在 Keycloak 里面创建的用户名完全一致。\n由于我们使用 SAML 认证，所以这里不需要设置该用户的密码，这里只是告诉 Connect，Keycloak 里面的用户 \u0026ldquo;mavlarn\u0026rdquo;，将作为 Amazon Connect 系统的管理员。\n后续的步骤，跟其他方式创建 Connect 实例没什么区别，最后创建以后，等1，2分钟，实例就会创建完成。创建成功后，打开实例详情，找到该实例的 ID：\nARN 中，最后的一串横线隔开的数字 d47fc0b2-83c2-4af9-b78a-6d312739b4a3 就是实例 ID。记下该 ID 备用。\n为 Amazon Connect 与 Keycloak 配置 SAML 接下来，在 Keycloak 中创建 Client，来作为 Amazon Connect 的认证客户端。\n为 Amazon Connect 创建Client 首先，下载 AWS 提供的 saml-metadata.xml文件，然后在 Keycloak 系统中确保选择了合适的Realm，然后点击 Clients 页面中的 \u0026ldquo;Import client\u0026rdquo; 按钮，打开页面：\n点 \u0026ldquo;Browser\u0026rdquo; 按钮，上传刚才下载的文件，输入Name 和 Description，由于这个Client是为 Connect 提供 SSO 的，所以这里的 Name 为 aws_connect，可以根据需要输入自己的名称。\n保存后，进入详情页，设置以下几项：\nIDP-Initiated SSO URL name: 输入 aws_connect，输入后，下面就会显示出：Target IDP initiated SSO URL: http://localhost:8080/realms/AWSDemo/protocol/saml/clients/aws_connect，这就是我们用来访问 Amazon Connect 时的入口 URL。\nIDP Initiated SSO Relay State: 输入 https://ap-northeast-2.console.aws.amazon.com/connect/federate/d47fc0b2-83c2-4af9-b78a-6d312739b4a3。这个地址是 Amazon Connect 的SAML URL，其中 ap-northeast-2 是我创建 Connect 的区域，如果您的 Connect 创建到了不同的区域，请进行修改。这个 URL 最后的 d47fc0b2-83c2-4af9-b78a-6d312739b4a3 是我们创建的 Connect 实例 ID，是在上面创建完成后，从 ARN 中得到的。\n在 Client 详情页中的 \u0026ldquo;Advanced\u0026rdquo; tab 页，有一个 Assertion Consumer Service POST Binding URL 设置，它就是 AWS 的 ACS(Assertion Consumer Service) 地址，导入 AWS saml-metadata.xml 文件创建 Client 时，这个值被设置成 https://signin.aws.amazon.com/saml。Keycloak 登录完成后，会携带 SAML Response，跳转到该地址，交给 AWS 进行验证，验证成功以后，再跳转到上面配置的 IDP Initiated SSO Relay State 配置的URL，从而访问 Connect 页面。\nClient 配置修改 我们使用从 AWS 下载的 saml-metadata.xml 文件，导入生成了 Client，但是这个客户端的部分配置还需要修改。进入新建的客户端的详情页，进入 Client scopes tab 页：\n点击 urn:amazon:webservices-dedicated 进入后，在搜索框输入 Role 搜索，会看到有两个 mapper 配置：\n看到他们的类型（Type，也就是映射类型）都是 User Attribute ，这是不对的，使用这种类型，就无法正确的映射角色，所以我们删除这两个mapper，重新创建。\n点击 Add mapper，选 By Configuration ，从弹出的页面中，选择 Role list：\n按照下面输入并保存：\n其中 Role attribute name，必须是 https://aws.amazon.com/SAML/Attributes/Role，它是 AWS 的SAML signin API在 验证 SAML Response 的时候，需要的属性，它的值必须是当前登录的用户的角色列表。通过上面的设置，用户在 Keycloak 登录后，就能将用户在 Keycloak 的角色赋给这个值。\n同样的，创建另一个mapper，这个 mapper 的类型是 User Property\n新建的值如下，名称和属性名都是 https://aws.amazon.com/SAML/Attributes/RoleSessionName，property 是 username ：\n通过这个配置，登录的当前用户的用户名，就会被赋给 RoleSessionName。\n还有，在创建一个 Hardcoded attribute 类型的mapper，来设置 Session Duration。这个值要跟 Connect 的 Session 有效期一致，否则可能会出现在 Keycloak 里面 Session 还未过期但是 Connect 里面已经过期的情况。Connect 中登录的用户的 Session 有效期是12小时，所以我们可以设置：\n属性名为 https://aws.amazon.com/SAML/Attributes/SessionDuration， 值 43000，单位是秒。\n最后，在这个 urn:amazon:webservices 的 Dedicated scopes 页中，进入 Scope Tab页，取消 Full scope allowed 的勾选，如下：\n如果没有取消这个勾选，这个 Client 中其他默认或内置的角色都会被赋予到角色中，而我们只需要我们刚才创建的 AWS 后台需要的角色。\nAWS 中设置身份提供商 接下来，需要在 AWS 中添加这个 Keycloak 为身份提供商。\n首先，我们需要下载我们安装的 Keycloak 的描述文件，该文件的地址为：\nhttp://localhost:8080/realms/AWSDemo/protocol/saml/descriptor\n其中 localhost:8080 是我们的 Keycloak 的地址，AWSDemo 是我们创建的 Realm 的名称，请根据您的 Keycloak 环境修改地址下载。该文件下载链接也可以从 Realm Setting 页面中的 Endpoints 后面的 SAML 2.0 Identity Provider Metadata 链接找到。\n然后，打开 AWS Console，进入 IAM 服务，进入 Identity providers，点击 Add Provider 按钮，进入创建页面，输入名称为 local-keycloak，上传刚才下载的文件，然后添加：\n创建 AWS 角色 在 AWS 中，要使用任何的服务，都需要相应的用户或角色。在这里，我们需要创建一个角色，从 Keycloak 登录过来的用户（客服或管理员），给他赋予这个角色，他才能够访问 Connect 服务，然后在 Connect 里面，根据用户应用内的角色进行操作，例如以客服身份接听来电。\n在 AWS Console 中，进入 Roles 页面，添加一个新的角色，选择 SAML 2.0 federation，在 SAML 2.0–based provider 中选择我们创建的 local-keycloak，勾选 Allow programmatic and AWS Management Console access，如下图：\n在下一步中，添加权限的页面，点 Create Policy 创建一个新的 Policy，Policy 的 JSON 格式的内容如下：\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;Statement1\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;connect:GetFederationToken\u0026#34;, \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:connect:ap-northeast-2:56xxxx27:instance/d47fc0b2-83c2-4af9-b78a-6d312739b4a3/user/${aws:userid}\u0026#34; ] } ] } Resource 里面的就是之前创建的 Connect 的实例的 ARN，再加 user后缀，注意使用自己创建的实例 ARN 替换。\n然后给这个 Policy 起一个名字，如 local_keycloak_federation_policy，然后创建：\n创建完成后，回到创建角色的页面，点击 Create Policy 按钮旁边的刷新按钮，然后输入 local_keycloak_federation_policy 就能找到新创建的 Policy，勾选上，给角色的名字设置一个合适的名称，如 local_keycloak_connect_role，创建该角色。\n如果您有多个 Connect 的实例，想都使用统一的 Keycloak 来实现SSO，那么只需要在这个角色的 Resource 设置多个实例的 ARN 即可，或者使用下面的方式设置条件：\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;Statement2\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;connect:GetFederationToken\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;connect:InstanceId\u0026#34;: [ \u0026#34;2fb42df9-78a2-2e74-d572-c8af67ed289b\u0026#34;, \u0026#34;1234567-78a2-2e74-d572-c8af67ed289b\u0026#34;] } } } ] } Keycloak 中创建用户、组以及角色 下面，就需要在 Keycloak 中创建用户，客服人员将会使用这些用户来登录 Connect 进行操作。而且，我们还需要在 Keycloak 中创建角色，这个角色将于 AWS 的角色对应，这样登录到 Keycloak 的用户才能在 AWS 的 Connect 上具有权限。\n首先建角色，在 Keycloak 中，确认选择合适的 Realm，进入 Client 菜单页，进入新建的 urn:amazon:webservices 客户端：\n新建角色，新角色的名称如下：\narn:aws:iam::568xxxxxxx27:role/local_keycloak_connect_role,arn:aws:iam::568xxxxxxx27:saml-provider/local-keycloak\n它由两部分组成，中间由逗号隔开，第一部分是创建的 AWS 的角色的 ARN，第二部分是刚创建的 AWS 的身份提供商的 ARN，这些都可以在相应资源的详情页里看到。（注意 568xxxxxxx27 是我的account id，为了安全起见，做了混淆）。\n保存后，进入 Users 菜单页，点 Create User 新建用户：\n注意这里的用户名必须跟之前在创建 Connect 实例时设置的管理员的用户名必须一致。\n创建完成后，进入 Credentials Tab 页，给用户设置一个密码， Temporary 后面的勾选可以去掉，去掉后用户登录后就不需要强制修改密码了。\n然后进入 Groups 菜单页，新建一个组，叫 connect-user-group，创建后在组详情页中，进入 Members Tab 页，将刚才创建的用户 mavlarn 加到这个组里：\n然后进入该组的 Role mapping Tab 页，点击 Assign Role 按钮，注意这里需要按照 Filter by clients 来过滤\n然后找到之前在 Keycloak 里创建的角色（可以输入名称查找，或者翻页）\n确认后，该组就被赋予这个角色，所有这个组中的成员也都具有这个角色了。而这个角色的命名方式： , ，也能映射到 AWS 内部的角色，从而让通过 Keycloak 登录的用户能够访问 Connect 服务。\n测试验证 值此为止，配置已经完成，我们可以访问 http://localhost:8080/realms/AWSDemo/protocol/saml/clients/aws_connect ，在弹出的页面输入管理员的用户名（即刚才创建的mavlarn）和密码，成功后就会跳转到 Amazon Connect 页面。其中 AWSDemo 是创建的 Realm，aws_connect 是我们创建的 Client。\n如果想从 Keycloak 退出，可以进入 Account 页面 http://localhost:8080/realms/AWSDemo/account， 点击 Signout 退出。\n创建客服用户 至此，我们已经能够用管理员账户通过 Keycloak 登录 Connect。接下来还需要创建其他客服用户。\n我们在 Keycloak 中配置了 Client 之后，使用的 Relay State 是 https://ap-northeast-2.console.aws.amazon.com/connect/federate/d47fc0b2-83c2-4af9-b78a-6d312739b4a3，这是我们的 Connect 的首页，即 Dashboard 页面。这对于管理员用户是可以的，但是对于普通客服人员，他应该是跳转到客服的工作台页面，这个地址是 https://ap-northeast-2.console.aws.amazon.com/connect/federate/d47fc0b2-83c2-4af9-b78a-6d312739b4a3?destination=%2Fconnect%2Fccp-v2。即通过后面的参数 ?destination=%2Fconnect%2Fccp-v2 来指定要跳转的目的地。\n所以，如果我们有自己的工作台和管理界面，可以使用统一的 SAML Client，但是，如果是使用 Connect 内置的工作台，就需要创建第二个 Client，配置跟第一个几乎一样，只是使用不一样的 Relay State 地址。\n然后，对于客服的用户，首先我们需要在 Keycloak 中创建这些用户，同时，我们还需要在 Connect 应用的用户管理里面添加这些用户，需要保证使用的用户名是一致。如果没有添加客户用户，或用户名有误，就会出现如下错误：\nAccess denied Your account has been authenticated, but has not been onboarded to this application. Contact your Administrator to onboard to Amazon Connect and try again. 如果不想每次都在 Connect 中手动添加用户，也可以通过 Connect API 通过 Keycloak 的插件来添加，或者使用 CSV 文件批量的添加。\nKeycoak 可能最在的问题 注意：在当前最新版 19.0.3 中，有可能会出现属性 https://aws.amazon.com/SAML/Attributes/Role 无法传递到 AWS 进行验证，从而导致出现错误：Error: Your request included an invalid SAML response. to logout, click here。出现这个错误就是因为 https://aws.amazon.com/SAML/Attributes/Role 或 https://aws.amazon.com/SAML/Attributes/RoleSessionName 没有在 SAML Response 里。 如果是因为前者，我们可以通过创建一个 Hardcoded attribute 类型的属性，将角色写死在值里，角色值在下面的步骤。这样的话，Keycloak 登录的用户会赋予这个写死的角色来访问 AWS，而不是通过用户组里设置的角色，需要注意。\n"},{"uri":"/workshop_connect_agent/2-agent_basic_functions/","title":"坐席基本功能设置","tags":["Amazon Connect","Agent"],"description":"配置 Amazon Connect，配置Agent的基本功能","content":"本节将介绍一些基本的 Amazon Connect 的功能设置。\n界面 首先，需要了解 Amazon Connect 有几个界面：\nAmazon Console 的 Connect 界面 即从 Amazon Console 找到 Connect 服务进入的页面，这里可以创建并配置 Connect 实例。如下就是其中一个配置页： Connect 管理页面 创建完Connect 实例以后，打开Connect 的管理界面： 坐席页面 坐席的应用页面有2个地址：\n基本CCP（Contact Control Panel）界面，仅包含拨号、接听的界面。 https://connect-xxxxx.my.connect.aws/ccp-v2\n坐席应用界面，包括基本CCP，以及Customer信息，Case，知识库（Wisdom）等页面。 https://connect-xxxxx.my.connect.aws/agent-app-v2\n如果要打开包含客户信息、case等界面的坐席应用，需要坐席具有相应的权限。默认情况下，坐席只有打开基本 CCP 界面的权限，需要在用户管理中，修改用户的 Security Profile 给他设置相应的权限。\n坐席基本通话功能 坐席状态 登录后，坐席可以设置自己的状态，默认只有两种状态，Available 和 Offline。只有在 Available 状态时，坐席才能接听到客户来电。\n我们也可以设置自定义的坐席状态，管理员登录到 Connect 的管理界面，从左侧菜单中找到用户管理-坐席状态菜单： 进入坐席状态列表页面，可以新建一个状态： 输入新状态的名称和描述，保存后，就可以在坐席的界面看到新的状态，坐席就可以修改自己的状态。坐席只有在 Available 状态时才能接听到来电。\n坐席通话界面、通话保持以及继续 当坐席 Available 状态时，有新客户来电时，页面上会收到提示： 此时，左侧的界面会显示来电，以及电话号码，右侧的 Customer Profile 界面会试图查询该用户并显示。再通话过程中或结束后，坐席也可以编辑该信息。（坐席需要具有相应权限才能显示该页面）。\n坐席接听后，就会开始通话： 坐席可以点击 Hold 进行通话保持，然后继续 Resume： 如果坐席未能及时接听，就会出现漏接电话提示： 当坐席完成客服电话挂断以后，坐席就会进入 After Call 阶段，此时坐席的通话界面不会完全结束，可以进行其他操作，例如修改客户信息，创建 Task 等。 例如创建后续任务，例如该用户后续要完成的操作等： 注意这时要创建任务之前，需要先创建一个quick connect。\n坐席外呼 坐席在CCP界面，也可以进行外呼，点击 Number pad 打开拨号界面，输入号码就可以外呼。\n坐席也可以点击CCP界面等 Quick Connect 按钮，再页面中输入号码进行外呼，但是要注意，各个地区的Connect实例，允许外呼的号码所在地区有一定限制。\n坐席转移呼叫 当坐席接听客户来电时，也可以通过 Quick Connect 按钮转接到外部电话，或者其他坐席：\n在这里，我们可以选择已经创建的 Quick Connect 的用户或者号码，也可以输入其他号码。比如下面的转接页面，我们可以选择之前创建的 mav1 user qc，将这个来电转出去。 进行转接之后，就可以看到如下界面： 这时，你也可以点击 Join 按钮，加入到通话中，这时，当前坐席、转接对象、以及用户就会形成一个三方通话。 如果需要退出三方通话，就可以点击 Leave 离开。\n注意在 Connect 中，无法转接到紧急号码，如 911 等。\nAgent登录并使用电话号码接听 AWS Connect可以允许坐席使用自己的电话接听。可以通过2种方式进行设置。\n坐席登录设置 坐席登录后，点击设置图标，打开坐席的设置页面： 在 Phone Type 类型设置中，选择 Desk Phone，并输入坐席自己的电话号码并保存，就可以讲来电转接到相应的号码上。 根据各个国家的要求，我们不能讲来电转接到任何号码上，例如在美国区域创建的Connect实例，我们只能转接到美国、加拿大、墨西哥等少数几个国家的号码上。并且，也不能转接到类似 911 这样的紧急呼叫的号码上。\n管理员设置 使用管理员登录并打开 Amazon Connect 的管理界面，左侧菜单中找到用户管理的菜单项： 进入用户管理界面，找到要设置的坐席的用户， 我们可以在这里设置坐席的基本信息，如名字、邮箱、密码（只有本地登录才可以修改密码，如果是SAML或AD方式登录不会有修改密码选项）等，也可以在这里设置坐席的转接电话。 坐席自动接听 如果坐席使用网页方式接听来电，即 Soft Phone 方式，就可以设置自动接听，管理员登录管理界面后，进入用户管理页面，进入用户详情：勾选 Auto-accept calls 即可。 "},{"uri":"/connect/","title":"Amazon Connect","tags":[],"description":"","content":"Amazon Connect 系列 Amazon Connect 配置 Amazon Connect 使用 Keycloak SAML 进行单点登录\n"},{"uri":"/connect/configure-amazon-connect-and-authing-with-saml-sso/","title":"配置Amazon Connect使用 Authing SAML进行单点登录","tags":["Amazon Connect","Authing","SAML"],"description":"配置 Amazon Connect 使用 Authing SAML 进行单点登录","content":"Authing 是在云上为企业和开发者提供专业的身份认证和授权服务，也支持 SAML 2.0 协议。本文介绍如何使用 Authing 认证服务，来实现 Amazon Connect 的单点登录。\n对于，SAML 协议以及使用 SAML 协议进行单点登录的详解，可以参考另一篇文章 配置 Amazon Connect 使用 Keycloak SAML 进行单点登录。在本文中，就只是简单介绍在 Authing 中配置时需要设置和注意的几个地方。\n创建 Authing 应用 首先需要在 Authing 里面创建一个应用，具体过程参考官方文档：成为 SAML2 身份源。即创建一个应用，然后在这个应用中启用 SAML，在配置当中，配置 ACS 地址为 https://signin.aws.amazon.com/saml。回调地址就是 https://ap-northeast-2.console.aws.amazon.com/connect/federate/d47fc0b2-83c2-4af9-b78a-6d312739b4a3 这样的地址。\n然后，还需要创建几个自定义 SAML Response 属性，就像在上一篇文档中创建的几个属性：\nhttps://aws.amazon.com/SAML/Attributes/Role https://aws.amazon.com/SAML/Attributes/RoleSessionName https://aws.amazon.com/SAML/Attributes/SessionDuration 其中 https://aws.amazon.com/SAML/Attributes/Role 就是要映射到 AWS 的角色，所以也需要先创建相应的身份提供商以及角色。\n在 AWS 中配置使用 Authing SAML 同样的，我们需要在 AWS 中创建 Authing 的身份提供商，有关这个，Authing 也提供了文档使用 SAML2 登录 AWS 控制台（中国区）。\n具体过程也是一样，先从 Authing 获取描述文件，然后在 AWS 创建的时候使用该描述文件导入，创建身份提供商后在创建角色，用于 Authing 登录的用户访问 AWS 的 Connect 服务。\n然后，的到角色的 ARN 和身份提供商的 ARN，用逗号连起来，就是在上面创建自定义 SAML Response 属性时 https://aws.amazon.com/SAML/Attributes/Role 的值。\n其他的都跟 配置 Amazon Connect 使用 Keycloak SAML 进行单点登录 类似，参考上一篇即可。\n"},{"uri":"/workshop_connect_agent/3-agent_skill_by_queue/","title":"Connect路由原理以及使用队列实现基于技能的路由","tags":["Amazon Connect","Agent"],"description":"Amazon Connect路由的原理，以及使用队列实现基于坐席技能的路由","content":"Amazon Connect使用队列(Queue)和路由配置(Routing Profile)实现基于坐席技能的路由。坐席-路由配置-队列之间的关系如下：\n每个坐席用户(User)都有一个 RoutingProfile(路由配置)，而每个 RoutingProfile 都跟多个队列(Queue)关联。\n当一个联系电话接入以后：\n会由跟电话号码关联的联系流 Contact Flow 处理，在这个 Contact Flow 中，会设置要转到某个队列（也可能直接转给某个Agent）。 根据 Queue 和 Routing Profile 和 Agent 的关系，该来电会被自动分发给下一个可用的 Agent（处于空闲时间最长的 Agent）。 也可以通过设置工作时间 hours of operation，来设置某个队列的工作时间，只有在工作时间内，来电才会转接到队列内的坐席。 创建队列 首先，我们需要为不同的用户类型，或者技能组，创建不同的队列。进入 Connect 的管理界面，从左侧的菜单找到 Routing - Queues，然后点击添加创建新的队列： 这里输入队列名称和描述，一般还需要设置 Outbound caller configuration，这时设置在外呼的时候，外呼使用的号码和流程。其中有些地区还需要设置 Caller ID。\nQuick connects 就是可以从这个队列的来电进行转接时，能够转接到哪些 quick connect。\n最后，也可以设置 Tags 标签，这些标签用于进行基于标签的权限控制，也可以在查询指标数据的时候，根据标签进行查询。\n修改或创建 Routing Profile 接下来就是创建 Routing Profile，在管理界面，找到菜单 Users - Routing Profiles，创建新的配置： 需要的配置如下：\n名称和描述 Set channels and concurrenc，设置可以通过该队列，接收哪些类型的联系请求。对于 Voice(电话) 类型，同时只能接听一路电话，而队列文本消息和任务，可以设置最多可以同时处理的数量。 Queues，设置该配置关联的队列，可以设置多个，并配置每个队列里能接收的channels，以及优先级、延时。通过这个优先级可以将不同级别的客户联系转发到不同级别的队列，坐席在接听的时候，会优先接听高优先级的（数字越低优先级越高），如果优先级一样，则优先处理延时低的。 Default outbound queue，即默认呼出队列，当通过配置或API进行自动外呼时，如果需要坐席接听外呼的电话，则有这个来配置由哪个队列的坐席接听外呼时的电话。 Tags，即标签，与上面的一样，用于基于标签的权限控制和指标查询。 设置 User - Routing Profile 然后，从菜单 Users - User management 进入用户管理列表，找到要设置的用户，设置关联的 Routing Profile ： 配置 Contact Flow 最后，需要在 Contact Flow 里配置要转发的队列，最基本的 Contact Flow 如下所示： 这里首先通过 Set working queue 设置要转发的队列，一般我们可以在这里配置要转发到哪个队列，比如下面就是转发到 BasicQueue 队列： 这里也可以动态的设置目标的队列，或者直接设置某一个Agent。\n然后再通过 Transfer to queue 转移，最后一个 Disconnect 的Block表示这个流程的自动的部分结束，这时该队列里的坐席就会弹出电话，进行接听。\n"},{"uri":"/connect/post-review-with-contact-flow/","title":"Amazon Connect实现客户评分反馈","tags":["Amazon Connect"," Contact Flow","Lex"],"description":"Amazon Connect实现客户评分","content":"在呼叫中心中，常见的一种使用场景是在客服或者机器人客服完成会话后，提示客户对服务进行评分或评价，以便对客户服务进行改进。在 Amazon Connect 中，我们同样可以通过 Contact Flow 来实现该功能。\n在这篇文章中，它通过Lex的到评分，并设置到 Contact 属性，再通过启用日志分析，使用Kinesis+Glue+Athena的日志分析方案来得到属性中的评分。在这篇文章中，我们尝试使用另一种方式来实现这一目标。\n实现原理 对客服进行评价，一般是客服人员挂断后，进入另一个流程，提示客户进行评价，客户用语音或键盘输入评价内容或评分后，再挂断电话。\n但是，现在除了电话客服，也会越来越多的使用消息客服，像短信、社交媒体消息，如企业微信、或Facebook Messenger等。在这种消息类型的场景下，流程也是类似的，也是客服人员完成当前会话，这时再进入另一个流程，提示客户评价，处理评价结果，再关闭该会话。\n在 Amazon Connect，我们使用一种 Set disconnect flow 的 block 类型来实现。当我们给一个流程设置了 Disconnect flow 以后，当客服结束会话的时候，就会进入这个 Disconnect flow 的流程。这时，客服人员已经退出，他不会再看到客户评价的任何内容。而评价的处理和保存可以通过 LexBot 或者 Lambda 函数来处理。该退出流程如下：\n它通过 Get customer input block来接受用户输入，再用 Set Contract attribute 将用户数据的评分保存在当前会话中，然后使用 Invoke AWS Lambda function 调用 Lambda 函数将用户评分保存到数据库中。然后才真正结束该会话。\nGet customer input Block Get customer input 用于接收用户输入，一般用于让当前用户输入密码进行验证，或者提供个人信息用于验证等。所以，这个 Block 不能用于一般的消息类的会话，只能用于语音会话。如果要用于消息类的，则需要通过 LexBot 来使用。也就是在 AWS 中配置 LexBot 接收用户的输入，识别其意图，然后针对识别的意图进行后续处理。所以在这个场景下，为了让我们的流程既能处理语音，也能处理消息，所以就使用了 LexBot。这里的 LexBot 只是提示用户评分，然后将评分结果存到 Slot 中。\nSet Contract attribute 使用 LexBot 识别到客户意图后，我们需要将该意图中 Slot 的值保存到会话中，这样才能供后面的 Lambda 函数使用。所以就需要使用 Set Contract attribute。\nInvoke AWS Lambda function 最后，收集到用户评分，就可以通过 Lambda 来处理，不管是保存到数据库，还是通过API发到外部系统，或者是某个 BI，都可以实现。\nLexBot 机器人 通过在 Connect 的流程中使用 Lex 机器人，我们可以实现机器人客服。一个 Lex 机器人（即LexBot），会有一个或多个意图（Intents），意图就是 Lex 机器人根据用户的语音或输入识别到的用户的“意图”，每个意图有可能会slot，用一个对话过程演示他们之间的关系如下：\n该机器人定义了一个订花的Intent，当用户输入订花相关的文字时，LexBot 识别到该意图。而这个意图需要几个Slot，如花的类型、包装方式等，LexBot 通过返回相应的提示语，来提示用户输入所需的值。当 LexBot 收集到了足够的信息以后，然后将该意图返回到 Contact 流程的下一步。\n创建 LexBot 首先，我们创建一个 Lex 机器人。\n进入 AWS Console，进入 Lex，新建一个 Bot，选择 Create a blank bot ， 名字为 PostChatReview，选择角色，Session超时时间默认即可，点下一步。在添加语言页面，选择所需的语言，这里选择英语，然后创建该 Bot。\n创建完成后，跳转到新建意图页面。输入名字 CustomerRate。\n在 Sample utterances 中，添加 ok， fine。\n在 Slots 中，添加一个类型为 AMAZON.Number ，名称为 rate 的slot，该 slot 的提示语是 Please rate customer service from 1 to 5. 5 is the best.\n在这个 LexBot 中，用户需要输入 ok 或 fine 来识别该评分的意图，然后 LexBot 发回 Please rate customer service from 1 to 5. 5 is the best. 给用户，提示用户评分，Lex 会判断用户的评分必须是数字类型。\n然后，在这个 LexBot 之前，我们需要在流程中提示用户 Would you like you proide feedback to improve our service? ，来引导用户输入 ok 或 fine，就能进入上面的意图。\n保存意图以后，还需要 Build 才可以使用该意图。如果需要，也可以进入测试页面进行简单测试。\n创建 Lambda 接下来，我们来实现一个简单的 Lambda，来处理用户的评分。在这里，为了掩饰，我们只是记录日志，如果用户想使用 DynamoDB 来保存用户评分，或者保存到其他的系统，可以自行在 Lambda 中实现。\n进入 AWS Lambda 的 Cosole，新建一个 lambda 函数 Connect_RateFeedback，内容如下：\nexports.handler = async (event) =\u0026gt; { console.log(\u0026#39;event:\u0026#39; + JSON.stringify(event)) // TODO implement const result = { result: \u0026#39;success\u0026#39; } const response = { statusCode: 200, body: JSON.stringify(result), }; return response; }; 添加 Lex 和 Lambda 到 Connect 中 创建好了 Lex 和 Lambda 函数以后，我们需要在 Connect 中使用他们，就需要先进入 AWS Console，进入 Connect 的Console，在 Contact flows 的配置中添加：\n添加 Disconnect flow 下面，使用管理员账户进入 Connect 的界面，添加一个 Contact flow。进入 Contact flows 的页面，点击新建流程，按照下面的流程创建一个名称为 Post Chat Feedback 的 flow：\n先通过 Get customer input block 接受用户输入： 提示语为 Would you like you proide feedback to improve our service?，Lex 的设置就是刚才新建的 Lex 机器人。添加 Intents CustomerRate。\n再通过 Set Contract attribute 将用户数据的评分保存在当前会话中： 它将 Lex 的 slot 中rate的值，保存到 Contact 的属性当中。\n然后使用 Invoke AWS Lambda function 来处理用户输入的评分。\n最后接一个提示，Thanks for your feedback.，最后结束这个流程。\n完成后，需要保存，并发布该流程。\n修改 Contact flow 下面，我们就来修改流程，添加客户评分的功能。打开正在使用的流程，比如这里使用的 Basic Chat，在流程结束前的某个位置，添加 Set disconnect flow 的 block，设置刚才创建的流程。\n它告诉 Connect，在流程结束前，先跳转到另一个流程，等那个流程完成了，整个会话才结束。\n除此以外，我们可能还需要在评价的时候，拿到关联的客服的用户名。首先，在上面这个 Basic Chat 流程中，会话还没有转接到客服，所以在这里没法拿到客服的id。然后，在上面的 disconnect flow 里，这时候客服已经结束了他的会话，所以这时候，也拿不到他的id。所以我们需要再添加一个流程，让它在这 Basic Chat 之后、并在客服关闭会话之前执行，根据文档，我们可以用 Whisper flow block 来实现。\nWhisper flow 是客服或者客户在加入会话的时候，用来显示（在Chat中）或播放（在Voice中）一段文本的block。如果我们设置了客服的 Whisper flow，对于Chat，当客服进入会话的时候就会看到；或客服在接听电话的时候听到。\n所以我们在 Basic Chat 中，添加一个 Set Whisper flow block：\n为客服设置，设置的流程是 Default agent whisper。\n然后，在修改 Default agent whisper，在流程中，将客服的用户名加到属性中：\n即，把系统属性 $.Agent.UserName 加到用户属性中。这样我们就能在之后执行的 Lambda 函数中拿到客服信息。\n权限说明 通过 disconnect flow 实现的会话后评分反馈的内容，对于支持当前会话的客服来说，是不可见的，即使对于 CallCenterManager 角色的用户也不可见，只有管理员才能通过会话历史查看其内容。\n测试 用管理员登录 Connect，从 Dashboard 中点击 “Test chat” 进入测试页面，如果你的默认流程不是刚才修改的流程，还需要修改 test setting 设置要测试的流程。\n同时，打开 https://.my.connect.aws/agent-app-v2/ 以客服账户登录。\n从客户测试页面发起会话，然后客服接收。客服点击 End chat 结束会话，至此，客服的页面就不会再更新，也看不到客户的评分。\n客服结束会话后，客户端看到客服已经离开，就会进入评分的流程，具体流程如下：\n检查 Lambda 的日志，我们可以看到它的参数如下：\n{ \u0026#34;Details\u0026#34;: { \u0026#34;ContactData\u0026#34;: { \u0026#34;Attributes\u0026#34;: { \u0026#34;agentName\u0026#34;: \u0026#34;mavlarn\u0026#34;, \u0026#34;rate\u0026#34;: \u0026#34;5\u0026#34; }, \u0026#34;Channel\u0026#34;: \u0026#34;VOICE\u0026#34;, \u0026#34;ContactId\u0026#34;: \u0026#34;b4e4bb7a-51fa-4579-a57e-0bb5474e17ea\u0026#34;, \u0026#34;CustomerEndpoint\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;+861086xxx5xx\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;TELEPHONE_NUMBER\u0026#34; }, \u0026#34;CustomerId\u0026#34;: null, \u0026#34;Description\u0026#34;: null, \u0026#34;InitialContactId\u0026#34;: \u0026#34;89bc52b3-668d-41bf-babf-610003374e69\u0026#34;, \u0026#34;InitiationMethod\u0026#34;: \u0026#34;DISCONNECT\u0026#34;, \u0026#34;InstanceARN\u0026#34;: \u0026#34;arn:aws:connect:us-east-1:5687xxxx9027:instance/17e41862-95d3-4eb0-84e3-8b72effac63f\u0026#34;, \u0026#34;LanguageCode\u0026#34;: \u0026#34;en-US\u0026#34;, \u0026#34;MediaStreams\u0026#34;: { \u0026#34;Customer\u0026#34;: { \u0026#34;Audio\u0026#34;: null } }, \u0026#34;Name\u0026#34;: null, \u0026#34;PreviousContactId\u0026#34;: \u0026#34;89bc52b3-668d-41bf-babf-610003374e69\u0026#34;, \u0026#34;Queue\u0026#34;: { \u0026#34;ARN\u0026#34;: \u0026#34;arn:aws:connect:us-east-1:5687xxxx9027:instance/17e41862-95d3-4eb0-84e3-8b72effac63f/queue/958b402c-e939-4fec-abab-53ea409e2320\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;CommonQueue\u0026#34;, \u0026#34;OutboundCallerId\u0026#34;: null }, \u0026#34;References\u0026#34;: {}, \u0026#34;SystemEndpoint\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;+1313xxxx679\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;TELEPHONE_NUMBER\u0026#34; } }, \u0026#34;Parameters\u0026#34;: { \u0026#34;rate\u0026#34;: \u0026#34;5\u0026#34; } }, \u0026#34;Name\u0026#34;: \u0026#34;ContactFlowEvent\u0026#34; } 我们在流程中设置的参数在 Details.ContactData.Attributes 里。\n"},{"uri":"/gaming/","title":"Amazon GameTech","tags":[],"description":"","content":"Amazon Game Tech 系列 Amazon Neptune "},{"uri":"/workshop_connect_agent/4-quick-connect-transfer-call/","title":"通过Quick Connect实现电话转接","tags":["Amazon Connect","Agent"],"description":"通过Quick Connect实现电话转接","content":"在 Amazon Connect 中，来电（或者消息）的转接，是通过 Quick Connect 的功能完成。在坐席的CCP界面，会有一个 Quick Connect 的按钮，坐席在接听电话时，可以讲来电转接到其他的坐席、队列、或者外部号码；如果坐席没有在接听，也可以通过 Quick Connect 呼叫外部号码。\n有关 Quick Connect 的工作原理和如何创建，可以参考官方文档\nQuick Connect 基本原理 Quick Connect 就是指定一个预定义的目标，这样坐席就可以通过选择这个预定义的 Quick Connect 进行外呼或者电话转接。\nQuick Connect 类型 根据 Quick Connect 的目标不同，有3种类型的 Quick Connect。\nPhone Number 即一个电话号码，可以将当前来电转接到该电话上。Phone Number 类型的 Quick Connect 可以在坐席接听状态，或者空闲状态使用。在CCP界面中，点击 Quick Connect，即可看到一个列表。 User （Agent） 即一个坐席用户用户，用于将当前来电转接给一个坐席。\nQueue 即一个队列，用于将当前来电转接到一个队列，然后由这个队列对应的坐席进行接听。\n对于后两种类型，则是在坐席接听电话的过程中，进行转接： Quick Connect 如何工作 Amazon Connect 中，以用户类型的 Quick Connect 为例，使用 Quick Connect 中进行转接的流程如下：\n客户拨打电话进行咨询 该电话对应某一个Contact Flow进行处理 在 Contact Flow 的流程中完成以后，电话进入某一个队列，等待坐席接听 空闲坐席Agent1接听该来电 Agent1 转接来电给 Agent2 该来电转到相应的 转接坐席 的 Contact Flow 转接 Contact Flow 完成后，坐席 Agent2 接收到来电请求，进行接听 所以，在转接给坐席的时候，实际上也是通过 Flow 来实现的。Connect 已经为我们提供了默认的流程 Default agent transfer，可以在 Flows 列表中找到。当 Agent1 通过 Quick Connect 转接给 Agent2 时，会执行这个流程。\n在这个流程中，会执行以下几个 Block：\n通过 Play prompt block，播放语音 “Transferring now\u0026hellip;”，这是 Agent1 会听到的提示音。 通过 Block Set working queue，设置 Agent2 所在的队列为工作队列。 通过 Block Transfer to queue 将当前电话转接到队列。 最后，Disconnect 表示当前流程结束，之后就由坐席接听。 创建 Agent Quick Connect 了解了 Quick Connect 的工作原理，下面就来看看如何创建 Agent 类型的 Quick Connect。\n创建 Quick Connect 根据上面的原理描述，我们需要一个转移到Agent的 Flow 流程，我们就使用默认的 Default agent transfer 即可，如果想要修改转接时的动作，比如说修改提示语，可以修改 Default agent transfer Flow，或者创建新的。\n然后，需要创建一个 Quick Connect，使用管理员登录 Connect 的管理界面，从菜单中找到 Routing - Quick Connects，进入 Quick Connect 列表页： 点击添加： 输入名字，描述信息，选择类型为 User，用户选择要转接的用户，Contact flow选择 Default agent transfer ，或者自己创建的 flow。\n关联队列 上面介绍了在转接的时候，是通过队列转接到队列中的坐席用户，所以需要将新创建的 Quick Connect，关联到队列上。\n在Connect 的管理界面，菜单中找到 Routing - Queues，进入队列列表，找到跟坐席用户关联的队列，点击进行编辑。\n在 Quick connects 部分，将新创建的 Quick Connect 添加到列表中，点击保存。在上面创建的 Quick Connect 中，用户是 mav2，所以，某个坐席用户在队列 BasicQuueue 中接听客户电话的时候，可以选择将当前电话，转接给 mav2 坐席。\n测试 现在某个坐席接听了客户电话后，就可以通过 Quick Connect 转接给 Mav2: 点击 Quick Connect，就会看到创建的列表： 转给 Mav2 后，就会看到如下页面： Queue 类型的 Quick Connect Queue 类型的 Quick Connect 的创建和配置过程，跟Agent类型的类似，只是在 Quick Connect 中，类型选择 Queue 类型，以及 Default queue transfer flow： 转接的时候，就会转到队列 BasicQueue，跟这个队列关联的所有坐席用户，都会接到这个转接的电话请求。\n"},{"uri":"/workshop_connect_agent/","title":"Amazon Connect Agent workshop","tags":[],"description":"","content":"Amazon Connect Agent workshop AWS Connect Agent基本应用。\n"},{"uri":"/","title":"","tags":[],"description":"","content":"我的 Blogs 配置 Amazon Connect 使用 Keycloak SAML 进行单点登录\nMain index AWS PSA Main index.\n"},{"uri":"/tags/agent/","title":"Agent","tags":[],"description":"","content":""},{"uri":"/tags/amazon-connect/","title":"Amazon Connect","tags":[],"description":"","content":""},{"uri":"/categories/amazon-connect/","title":"Amazon Connect","tags":[],"description":"","content":""},{"uri":"/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"/tags/amazon-pinpoint/","title":"Amazon Pinpoint","tags":[],"description":"","content":""},{"uri":"/categories/amazon-pinpoint/","title":"Amazon Pinpoint","tags":[],"description":"","content":""},{"uri":"/tags/analytics/","title":"Analytics","tags":[],"description":"","content":""},{"uri":"/tags/endpoint/","title":"Endpoint","tags":[],"description":"","content":""},{"uri":"/pinpoint/","title":"Pinpoints","tags":[],"description":"","content":""},{"uri":"/tags/channel/","title":"Channel","tags":[],"description":"","content":""},{"uri":"/tags/contact-flow/","title":" Contact Flow","tags":[],"description":"","content":""},{"uri":"/tags/lex/","title":"Lex","tags":[],"description":"","content":""},{"uri":"/tags/authing/","title":"Authing","tags":[],"description":"","content":""},{"uri":"/tags/saml/","title":"SAML","tags":[],"description":"","content":""},{"uri":"/tags/keycloak/","title":"Keycloak","tags":[],"description":"","content":""}]